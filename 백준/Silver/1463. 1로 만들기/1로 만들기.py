"""
idea
최적 부분 구조로 생각해봤을 때, 매 반복마다 x가 3으로 나누어 떨어지는 경우,
2로 나누어 떨어지는 경우, 아닌 경우가 있고 그 중 언급한 순서대로 우선순위가 생긴다.
-1연산을 기본으로 하고 조건에 맞을 때 /2와 /3을 적용
d[i] = i를 1로 만들기 위한 최소 연산 횟수일 때
d[i] = min(d_{i-1}, d_{i//2}, d_{i//3}) + 1
"""
n = int(input())
d = [0] * 1000001
for i in range(2, n+1) :
    d[i] = d[i-1] + 1
    if i % 2 == 0 :
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0 :
        d[i] = min(d[i], d[i // 3] + 1)

print(d[n])


